---
layout: blogpage
title: LeetCoding Experiences!
comments: true
tags: LeetCode Note
---

<p>既然开始刷题了，就要刷个明白！所以..！一边做，一边记录 Python 和 C++ 的语法/算法技巧吧 ~</p>
<p style="font-weight: bold">总结一下LeetCode里得到的经验！( ´ ▽ ` )</p>

<h2>2. Add Two Numbers</h2>
<p class="tag"># Linklist Pointer</p>

{% highlight python %}
    class Solution:
        def addTwoNumbers(self, l1, l2):
            carry = 0
            res = n = ListNode(0)
            while l1 or l2 or carry:
                if l1:
                    carry += l1.val
                    l1 = l1.next
                if l2:
                    carry += l2.val
                    l2 = l2.next
                carry, val = divmod(carry, 10)
                n.next = n = ListNode(val)
            return res.next
{% endhighlight %}

<h2>4.</h2>
<p>Python里求均值、中位数和众数的方法：</p>
{% highlight python %}
    import numpy as np
    # AVG
    np.mean(nums)

    # Median
    np.median(nums)

    # Mode
    counts = np.bincount(nums)
    np.argmax(counts)
{% endhighlight %}

<p>I used a silly method at first, with pretty slow speed.</p>
<p>Check out <a href="https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2481/Share-my-O(log(min(mn)))-solution-with-explanation">
    this O(log(min(m,n))) solution then!</a></p>


<h2>9. Palindrome Number</h2>

<p class="tag"># String </p>
<p>C++11 introduces std::stoi (and variants for each numeric type) and std::to_string,
    the counterparts of the C atoi and itoa but expressed in term of std::string.</p>
<p>When choosing convert int to string in C++, simply <code>#include &lt;string&gt;</code> and call it to handle variant length string! </p>
{% highlight cpp %}
        std::string str = std::to_string(x);
        string ss = to_string(x);
        int len = ss.length();
        for(int i=0, j=len-1; i<j; i++, j--) if(ss[i] != ss[j]) return false;
{% endhighlight %}
<p>A pure math implementation is:</p>
{% highlight cpp %}
class Solution {
public:
    bool isPalindrome(int x) {
        if(x < 0 || (x != 0 && x % 10 == 0))
            return false;
        long int sum = 0;
        long int temp = x;
        while(temp > 0){
                sum = 10 * sum + temp % 10;
                temp /= 10;
        }
        if(x == sum){
            //printf("True");
            return true;
        }
        else{
            //printf("False");
            return false;
        }
    }
};
{% endhighlight %}


<h2>12. Integer to Roman</h2>

<p>C++ 里的map底层是用类似红黑树的方式存的，默认按照key排序，而且不能直接调用sort函数对value排序。</p>
<p>如果一定要按value排序，该怎么做呢！</p>
{% highlight cpp %}
// 先定义好重载运算符的struct
typedef pair<string, int> PAIR;

struct CmpByValue {
    bool operator()(const PAIR& lhs, const PAIR& rhs) {
    return lhs.second > rhs.second;
    }
};

// 然后把map中元素转存到vector中按Value排序！
vector<PAIR> vec(ref.begin(), ref.end());
sort(vec.begin(), vec.end(), CmpByValue());


{% endhighlight %}
