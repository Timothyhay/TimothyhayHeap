---
layout: blogpage
title: All about Dynamic Programming
comments: true
tags: LeetCode Note
---

<blockquote>
    <p>Those who cannot remember the past are condemned to repeat it.</p>
    <p>—— George Santayana</p>
</blockquote>

<p>Usually, solving and fully understanding a dynamic programming problem is a 4 step process</p>:

<ol>
<li>Start with the recursive backtracking solution</li>
<li>Optimize by using a memoization table (top-down[2] dynamic programming)</li>
<li>Remove the need for recursion (bottom-up dynamic programming)</li>
<li>Apply final tricks to reduce the time / memory complexity </li>
</ol>

<p> All solutions presented below produce the correct result, but they differ in run time and memory requirements. </p>

<p>
    As the problem has an <strong>optimal substructure</strong>, it is natural to cache intermediate results.
    We ask the question dp(i, j): does text[i:] and pattern[j:] match?
    We can describe our answer in terms of answers to questions involving smaller strings.
</p>

